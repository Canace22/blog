---
title: AI赋能存量项目——从函数助手到业务伙伴
categories: 'AI探索'
author: Canace
comments: true
toc: true
date: 2025-12-12 14:43:49
---

## 一、从"传统编程"到"面向大模型编程"

在探索如何让 AI 真正赋能我们的存量项目之前，我们需要先完成一次思维上的"升级"——从传统的编程模式，过渡到面向大模型（LLM）的编程模式。这不是简单的工具替换，而是一场编程范式的革命。

### 1. 什么是 LOP？——面向大模型编程的几种模式

工欲善其事，必先利其器。在深入实践之前，我们先来理解 **LOP（Large Language Model Oriented Programming）** 的核心概念。

**LOP 即面向大模型编程**，它彻底颠覆了传统编程的模式。传统编程中，我们需要写好每一行逻辑，程序严格按照我们的指令执行；而在 LOP 模式下，我们只需要编写 Prompt + 少量代码，大模型就能动态生成逻辑。这种转变带来的想象空间是巨大的。

目前，LOP 主要有以下几种使用模式，每种模式都有其适用场景：

- **Direct Prompt-to-Code（直接提示到代码）**：单轮 Prompt 直接生成完整可运行产物，无中间状态、无工具调用、无外部记忆。这种方式简单直接，适合快速原型开发。**实践示例**：使用 Cursor 的 `Cmd+K`、Claude Artifacts、Gemini Code Execution 一键生成完整项目。

- **Autonomous Agent Programming（自主代理编程）**：AI 可以自主进行多轮工具调用（编辑文件、运行终端、读取错误日志、自我迭代），具备长期记忆和工作区状态。这种方式让 AI 更像一个真正的"开发者"。**实践示例**：在 Cursor 中让 AI 自己写代码、跑测试、修 bug，全程自主完成。

- **Chain-of-Verification + Structured Reasoning for Code（验证链 + 结构化推理）**：在生成最终代码前，强制模型进行显式推理链（技术选型 → 文件结构 → 边缘 case → 安全性），大幅降低幻觉问题。这种方式特别适合复杂场景。**实践示例**：在 Prompt 中加入 `...` 标签引导推理，或直接使用 Claude 3.5 的 long-thinking 模式。

- **Retrieval-Augmented Code Generation（检索增强代码生成）**：通过检索向量数据库中的私有代码库/文档/组件作为 context，解决超过 100k token 的大型项目理解问题。这是处理存量项目的关键能力。**实践示例**：Cursor 的 `@codebase` 功能，让 AI 理解整个项目的上下文。

- **Skeleton-then-Fill（骨架填充）**：开发者先写高层次结构或占位注释（skeleton），模型只负责填充细节，极大降低结构错误率。这种方式结合了人的架构能力和 AI 的实现能力。**实践示例**：先写文件树结构 + `// LOP: 这里需要一个带分页的表格组件` 这样的占位注释，然后让 Claude 填充完整实现。

- **Self-Healing / Iterative Refinement Loop（自愈/迭代优化循环）**：运行代码 → 捕获错误/测试失败 → 把错误日志反馈给模型 → 自动 patch → 循环直到全部通过。这种方式实现了真正的"自愈"能力。**实践示例**：Cursor 的 "Fix with AI" 功能，自动修复错误直到代码通过测试。

### 2. 核心差异：从"指令者"到"沟通者"

理解了 LOP 的几种模式后，我们需要认识到这两种编程范式的本质差异：

**传统编程模式**中，我们是代码的"上帝"。每一个字符、每一行逻辑都由我们精确控制，我们给计算机下达的是确定性的、无歧义的指令。我们的核心工作就是"写代码"——把想法直接转化为代码。

**面向大模型编程模式**则完全不同。我们更像一个"项目经理"或"架构师"，而不是一个"码农"。我们不再是逐行编写代码，而是通过自然语言向 AI 描述我们的"意图（Intent）"。AI 是我们能力超强的"实习生"或"结对伙伴"，它负责将意图转化为具体的代码实现。

这种转变意味着，我们的核心工作从"写代码"变成了**"精确地描述问题、提供上下文、以及审查和验证结果"**。这是一个从"执行者"到"思考者"的转变。

### 3. 工具进化：编辑器转换

思维模式的转变，必然带来工具的革新。传统的 IDE（如 `VSCode`、`IntelliJ IDEA`）虽然功能强大，但在与 AI 交互时存在天然的割裂感——你需要切换到另一个网站，复制代码，再粘贴回来，整个过程繁琐且低效。

**AI-Native 的编辑器**，如 **Cursor**，正是在这个背景下应运而生的。它将聊天窗口、代码库索引、命令系统深度集成到编辑器中。你不再需要"切换到一个聊天网站，复制代码，再粘贴回来"，而是在编辑器内与一个**"熟悉你整个项目"**的 AI 直接对话。

这种深度集成带来的体验是革命性的：AI 能够理解你的项目结构、代码风格、业务逻辑，甚至能够直接操作文件系统、运行测试、修复错误。这才是实现高效 AI 协作的真正基础。

---

## 二、超越"写函数"：让 AI 融入业务开发

如果你还在用 AI 写一些独立的、无上下文的小函数，那么你可能只发挥了它 10% 的能力。真正的价值在于让 AI 理解我们的业务，参与到整个开发流程中。

### 1. 第一步：让 AI "认识"我们的项目

AI 并非天生就知道我们的项目规范。我们需要主动"喂"给它上下文。这就像新同事入职，我们要给他看项目文档一样。

**建立 Project Rule**：我们可以通过在项目中建立类似 `@-rules` 或 `.prompt` 的文件，定义项目的核心规则。例如：

- 技术栈（`React` + `TypeScript` + `TailwindCSS`）
- 编码规范（遵循 Airbnb Style Guide）
- 目录结构约定（组件放在 `src/components`，API 请求放在 `src/services`）
- 关键的业务术语解释

当 AI 获得了这些"项目级知识"后，它生成的代码就会更符合我们的项目规范，而不是通用的"互联网模板代码"。

#### 1.1 编写高质量的 CLAUDE.md（或 AGENTS.md）

在 Claude Code、Cursor 等工具中，`CLAUDE.md`（或 `AGENTS.md`）是让 AI 了解你代码库的关键文件。它会在**每次对话开始时**自动加载，因此是最重要的配置。

**核心原则：少即是多**

- **指令数量限制**：前沿的 LLM 通常只能可靠地遵循约 150-200 条指令。Claude Code 的系统提示已经包含约 50 条指令，这意味着你的 `CLAUDE.md` 应该尽可能精简。
- **文件长度建议**：一般共识是 `< 300 行` 最佳，更短更好。HumanLayer 的根 `CLAUDE.md` 文件甚至不到 60 行。
- **通用性原则**：由于 `CLAUDE.md` 会进入每次对话，其内容必须是**普遍适用的**。避免包含特定任务或场景的指令（比如"如何设计数据库表结构"），这些应该放在单独的文件中。

**WHAT、WHY、HOW 框架**

一个好的 `CLAUDE.md` 应该回答三个核心问题：

- **WHAT（是什么）**：告诉 AI 你的技术栈、项目结构、代码库地图。在 monorepo 中尤其重要，要说明哪些是应用、哪些是共享包、各自的用途。
- **WHY（为什么）**：告诉 AI 项目的**目的**和各个部分的功能。帮助 AI 理解业务逻辑和设计意图。
- **HOW（怎么做）**：告诉 AI 如何在这个项目上工作。例如使用 `bun` 而不是 `node`、如何运行测试、如何验证更改、如何执行类型检查等。

**渐进式披露（Progressive Disclosure）**

不要把所有信息都塞进 `CLAUDE.md`。相反，使用渐进式披露：

- 将任务特定的指令放在**单独的 markdown 文件**中，使用自描述的文件名，例如：
  ```
  agent_docs/
    ├── building_the_project.md
    ├── running_tests.md
    ├── code_conventions.md
    ├── service_architecture.md
    ├── database_schema.md
    └── service_communication_patterns.md
  ```
- 在 `CLAUDE.md` 中列出这些文件及其简要描述，指示 AI 在需要时读取相关文件。
- **优先使用指针而非副本**：不要在这些文件中包含代码片段（它们会很快过时），而是使用 `file:line` 引用指向权威的上下文。

**不要用 AI 做 Linter 的工作**

- LLM 相比传统 linter 和 formatter 来说**昂贵且慢**。应该始终优先使用确定性工具。
- 代码风格指南会不可避免地增加大量指令和大部分无关的代码片段，降低 LLM 的性能和指令遵循能力。
- **LLM 是上下文学习者**：如果你的代码遵循某种风格指南或模式，通过几次代码库搜索（或一个好的研究文档），AI 应该能够遵循现有的代码模式和约定，而无需明确告知。
- 考虑设置 Hook（如 Claude Code 的 Stop hook）来运行 formatter 和 linter，并将错误呈现给 AI 修复，而不是让 AI 自己发现格式问题。

**不要自动生成 CLAUDE.md**

- `CLAUDE.md` 是 harness 的**最重要的配置**，影响工作流的每个阶段和每个产物。
- 一行糟糕的代码只是一行糟糕的代码，但一行糟糕的 `CLAUDE.md` 可能会产生大量糟糕的代码。
- 应该仔细思考每一行内容，手动精心编写，而不是使用自动生成工具。

### 2. 核心技巧：通过"约束"和"任务拆解"驾驭 AI

**约束 (Constraint)**：这是与 AI 协作的精髓。不要给 AI 一个开放性的问题，而要给它一个带有一系列约束的"填空题"。

- **Agent 设置**：在提问时明确角色，例如"你现在是一个资深的后端工程师，请使用 `NestJS`..."。
- **Rule 设定**：明确告知"不要使用 `any` 类型"、"必须进行错误处理"、"API 响应格式必须遵循 `{code, data, message}` 结构"等。

**工作流/任务拆解 (Task Decomposition)**：不要指望 AI 一步到位完成一个复杂的需求（比如"开发一个用户登录功能"）。我们需要像敏捷开发一样，将大任务拆解成小步骤，然后引导 AI 逐一完成。

- **步骤一**："请为用户登录功能设计数据库表结构，包含字段 a, b, c。"
- **步骤二**："基于上面的表结构，使用 `TypeORM` 创建对应的 Entity 文件。"
- **步骤三**："编写一个 `login` 的 Service 方法，实现登录逻辑，注意密码要加密比对。"
- **步骤四**："为这个 `login` 方法编写单元测试。"

通过这种方式，每一步的输出都是可控和可验证的，最终组合成一个高质量的功能。

#### 2.1 接受"第一次尝试通常是垃圾"的现实

**将 AI 视为"不会学习的初级开发者"**

这是与 AI 协作最有效的心理模型。就像带一个每天都会失忆的初级开发者一样：

- **第一次尝试（95% 垃圾率）**：AI 会构建关于你系统的上下文，你识别出真正的挑战，但代码通常完全错误。这是正常的！不要期望第一次就完美。
- **第二次尝试（50% 垃圾率）**：AI 理解了细微差别，你已经定义了具体方法，但一半情况下仍然不可用。继续迭代。
- **第三次尝试（终于可用）**：AI 实现了可以迭代和优化的东西，你不断审查和纠正，这成为你的起点，而不是最终代码。

**这不是失败，这是过程！** 期望第一次就完美，就像期望一个初级开发者在没有上下文的情况下完美实现一个复杂功能一样不现实。

**迭代是常态，不是例外**

- 忘记"一次性完美代码生成"的承诺。作为工程师，你的工作是找到问题的最佳解决方案，而不仅仅是写一堆代码。
- 通常需要**三次尝试**才能得到可用的代码。第一次建立上下文，第二次理解细微差别，第三次才真正实现。
- 每次迭代都要将学习反馈给 AI，逐步完善解决方案。

### 3. 精准沟通：为不同角色和场景定制工作流

**明确意图**：开发、测试、需求分析，不同角色的工作流是不同的。

- **开发者**：关注代码实现、重构、添加单元测试。
- **测试者**：可以要求 AI "为这个函数生成 5 个边界条件的测试用例"、"根据这段需求描述，编写对应的 `BDD` 测试脚本"。
- **需求/产品**：可以要求 AI "总结一下这个文件的主要功能"、"用伪代码解释这段业务逻辑"。

**使用 Command (精准指令)**：善用 AI 工具提供的特殊命令。在 Cursor 中，使用 `@` 符号可以精确地引用某个文件或目录（`@src/utils/date.ts`），这比复制粘贴代码片段要高效和准确得多。这等于在告诉 AI："请聚焦在这个文件的上下文中进行思考"。

**渐进式 Rule**：与 AI 的交互是一个持续沟通的过程。第一次生成的结果不完美很正常。我们可以通过追加 Rule 来逐步修正它。

- **初次请求**："写一个数据请求函数。"
- **追加 Rule 1**："很好，现在给它加上 loading 状态处理。"
- **追加 Rule 2**："再加上统一的错误捕获和上报逻辑。"

这个过程就像 `Code Review`，我们不断提出修改意见，AI 不断迭代，最终得到满意的结果。

---

## 三、个人提效实践（以 Cursor 为例）

理论说了很多，我们来看一些个人可以立刻上手的实践方法。

### 1. 理解模型差异

不同的模型有不同的特点。`GPT-4` 更聪明，逻辑推理能力强，适合复杂的任务和重构，但速度慢、成本高。`Claude 3 Sonnet/Haiku` 或 `GPT-3.5` 速度快，适合快速的代码补全、简单的问答。根据任务的复杂度，选择合适的模型，可以平衡效率和成本。

### 2. "教学相长"：沉淀你的 AI 知识库

AI 编程的经验是宝贵的财富。当你发现一个特别好用的 Prompt 模板，或者一套针对某个特定场景的 Rule 时，一定要记录下来。

**建立个人 Prompt Snippets**：将这些高效的指令和规则沉淀下来，形成自己的"弹药库"。下次遇到类似问题，可以直接调用。这个过程不仅是在"使用"AI，更是在**"训练"自己如何与 AI 高效协作**，构建自己新的认知体系。

### 3. 上下文管理：解决 AI 的"失忆"问题

AI 最大的挑战之一是**无法在会话之间保留学习**（除非你花时间手动给它"记忆"）。通常，每次对话都从零开始。

**解决方案：**

- **CLAUDE.md 文件**：使用项目规则文件（详见"二、1.1"章节）来管理上下文，包含架构决策、代码库中的常见模式、陷阱和变通方法、相关文档链接。
- **工具集成**：利用 MCP（Model Context Protocol）集成，将 AI 连接到：
  - Linear（工单上下文）
  - Notion 或 Canvas（文档和知识库）
  - 代码库索引（让 AI 理解整个项目结构）
- **会话记忆管理**：对于重要的上下文，考虑在每次会话开始时主动提供给 AI，而不是依赖它"记住"。

### 4. 多 Agent 协作：像管理小团队一样

高级实践是将 AI 当作一个**小团队**来管理，而不是单个助手。

- **并行开发**：同时运行多个 AI 会话，每个专注于不同的任务或模块。
- **角色分工**：给不同的 AI 会话分配不同的角色（前端专家、后端专家、测试专家等）。
- **上下文共享**：通过 `CLAUDE.md` 和共享文档确保所有"团队成员"理解项目规范。

这种方式可以显著提高开发效率，就像同时与多个开发者结对编程一样。

---

## 四、最后的防线：如何保证代码质量？

AI 生成的代码再好，也可能存在隐藏的 Bug 或不符合最佳实践。我们作为开发者，永远是质量的最后一道防线。

- **人类审查是不可替代的**：AI 是副驾驶（Copilot），你才是机长（Pilot）。你必须完全理解 AI 生成的每一行代码，并为它的最终质量负责。绝对不能盲目地"CV"（`Ctrl+C`, `Ctrl+V`）。
- **Code Review 愈发重要**：团队的 `Code Review` 流程变得更加关键。审查的重点可以从检查语法错误，转移到更高维度的架构设计、业务逻辑的合理性上。
- **自动化测试是金标准**：单元测试、集成测试是验证 AI 代码质量最可靠的手段。你甚至可以要求 AI "为我刚才生成的代码编写全面的单元测试"，让 AI 自己来辅助验证其工作的正确性。
- **利用 AI 提升质量**：反过来，我们也可以利用 AI 来提升已有代码的质量。例如，选中一段代码，让 AI "重构这段代码，使其更具可读性"、"为这段代码补充 `JSDoc` 注释"、"找出这段代码中潜在的性能问题"。

### 1. 12-Factor Agents：构建可靠 LLM 应用的原则

参考 12-Factor Agents 的原则，以下是一些核心实践：

- **拥有你的提示词（Own your prompts）**：将提示词版本化、测试化，就像代码一样管理。
- **拥有你的上下文窗口（Own your context window）**：精心管理输入到 LLM 的上下文，确保相关性和聚焦性。
- **工具就是结构化输出（Tools are structured outputs）**：将工具调用视为结构化输出，确保类型安全和可预测性。
- **统一执行状态和业务状态（Unify execution state and business state）**：确保 AI 的执行状态与业务状态保持一致。
- **小且专注的 Agent（Small, focused agents）**：不要试图构建一个"万能"的 Agent，而是构建多个小且专注的 Agent，每个负责特定任务。

这些原则帮助我们从"快速原型"走向"生产就绪"的 AI 应用。

## 参考文献

- [First attempt will be 95% garbage: A staff engineer's 6-week journey with Claude Code](https://www.sanity.io/blog/first-attempt-will-be-95-garbage)
- [Writing a good CLAUDE.md](https://www.humanlayer.dev/blog/writing-a-good-claude-md)
- [12-factor-agents](https://github.com/humanlayer/12-factor-agents/tree/main)
- [与Cursor结对编程四个月，我顿悟了！](https://mp.weixin.qq.com/s/RyBYqG04wR1Hq2CbfxU2eg)
- [AIGC主导项目开发的最佳实践](https://www.yuque.com/jujingyi-mzjzr/bg139y/gc7xcm7r9f5e4g5z?singleDoc#R9619)
- [提示工程指南](https://www.promptingguide.ai/zh)
- [AI for Coding：从 Vibe Coding 到规范驱动开发](https://mp.weixin.qq.com/s/HaazAEMGqH1GBTmn9qI73g)